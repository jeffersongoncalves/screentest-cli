import puppeteer from 'puppeteer';
import sharp from 'sharp';
import fs from 'fs';
import path from 'path';

const config = {{CONFIG_JSON}};

function log(data) {
  console.log(JSON.stringify(data));
}

async function main() {
  const browser = await puppeteer.launch({
    headless: 'new',
    args: ['--no-sandbox', '--disable-setuid-sandbox', '--disable-dev-shm-usage'],
  });

  try {
    for (const theme of config.themes) {
      const page = await browser.newPage();

      await page.setViewport({
        width: config.viewport.width,
        height: config.viewport.height,
        deviceScaleFactor: config.viewport.deviceScaleFactor,
      });

      await page.emulateMediaFeatures([
        { name: 'prefers-color-scheme', value: theme },
      ]);

      // Login (session cookies are shared across pages in the same browser,
      // so subsequent themes may already be authenticated and redirect to dashboard)
      await page.goto(`${config.baseUrl}/admin/login`, { waitUntil: 'networkidle0' });

      const needsLogin = !page.url().includes('/admin/login') ? false
        : !!(await page.$('input[type="email"]') || await page.$('[name="data.email"]'));

      if (needsLogin) {
        const emailSelector = (await page.$('[name="data.email"]'))
          ? '[name="data.email"]'
          : 'input[type="email"]';
        const passwordSelector = (await page.$('[name="data.password"]'))
          ? '[name="data.password"]'
          : 'input[type="password"]';

        await page.type(emailSelector, config.user.email);
        await page.type(passwordSelector, config.user.password);
        await page.click('button[type="submit"]');
        await page.waitForNavigation({ waitUntil: 'networkidle0' });
      }

      for (const screenshot of config.screenshots) {
        try {
          await page.goto(`${config.baseUrl}/${screenshot.url}`, { waitUntil: 'networkidle0', timeout: config.navigationTimeout });

          // Execute before actions
          for (const action of (screenshot.before || [])) {
            switch (action.action) {
              case 'click':
                await page.click(action.selector);
                break;
              case 'hover':
                await page.hover(action.selector);
                break;
              case 'wait':
                await new Promise(r => setTimeout(r, action.delay || 500));
                break;
              case 'type':
                await page.type(action.selector, action.value);
                break;
              case 'select':
                await page.select(action.selector, action.value);
                break;
              case 'scroll':
                await page.evaluate((sel) => document.querySelector(sel)?.scrollIntoView(), action.selector);
                break;
            }
          }

          const outputDir = path.join(config.outputDir, theme);
          fs.mkdirSync(outputDir, { recursive: true });

          const filePath = path.join(outputDir, `${screenshot.name}.${config.format}`);

          let element = screenshot.selector === 'body' ? page : await page.$(screenshot.selector);
          if (!element) element = page;

          const buffer = await element.screenshot({ type: config.format === 'jpg' ? 'jpeg' : 'png' });

          if (screenshot.crop) {
            const cropped = await sharp(buffer)
              .extract({ left: screenshot.crop.x, top: screenshot.crop.y, width: screenshot.crop.width, height: screenshot.crop.height })
              .toBuffer();
            fs.writeFileSync(filePath, cropped);
          } else if (config.format === 'webp') {
            const converted = await sharp(buffer).webp().toBuffer();
            fs.writeFileSync(filePath, converted);
          } else {
            fs.writeFileSync(filePath, buffer);
          }

          log({ type: 'progress', name: screenshot.name, theme, status: 'done', path: filePath });
        } catch (err) {
          log({ type: 'progress', name: screenshot.name, theme, status: 'error', error: err.message });
        }
      }

      await page.close();
    }
  } finally {
    await browser.close();
  }

  log({ type: 'complete' });
}

main().catch(err => {
  console.error(err);
  process.exit(1);
});
